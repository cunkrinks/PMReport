/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package pmreport;

import java.awt.BorderLayout;
import java.awt.Desktop;
import java.util.List;
import java.awt.Toolkit;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JDialog;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JProgressBar;
import javax.swing.JScrollPane;
import javax.swing.JTable;
import javax.swing.filechooser.FileFilter;
import javax.swing.filechooser.FileNameExtensionFilter;
import javax.swing.table.DefaultTableModel;
import org.apache.poi.ss.SpreadsheetVersion;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellStyle;
import org.apache.poi.ss.usermodel.CreationHelper;
import org.apache.poi.ss.usermodel.DataConsolidateFunction;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.util.AreaReference;
import org.apache.poi.ss.util.CellRangeAddress;
import org.apache.poi.ss.util.CellReference;
import org.apache.poi.xddf.usermodel.chart.AxisPosition;
import org.apache.poi.xddf.usermodel.chart.BarDirection;
import org.apache.poi.xddf.usermodel.chart.BarGrouping;
import org.apache.poi.xddf.usermodel.chart.ChartTypes;
import org.apache.poi.xddf.usermodel.chart.LegendPosition;
import org.apache.poi.xddf.usermodel.chart.MarkerStyle;
import org.apache.poi.xddf.usermodel.chart.XDDFBarChartData;
import org.apache.poi.xddf.usermodel.chart.XDDFCategoryAxis;
import org.apache.poi.xddf.usermodel.chart.XDDFCategoryDataSource;
import org.apache.poi.xddf.usermodel.chart.XDDFChartLegend;
import org.apache.poi.xddf.usermodel.chart.XDDFDataSourcesFactory;
import org.apache.poi.xddf.usermodel.chart.XDDFLineChartData;
import org.apache.poi.xddf.usermodel.chart.XDDFNumericalDataSource;
import org.apache.poi.xddf.usermodel.chart.XDDFValueAxis;
import org.apache.poi.xssf.usermodel.XSSFChart;
import org.apache.poi.xssf.usermodel.XSSFClientAnchor;
import org.apache.poi.xssf.usermodel.XSSFDrawing;
import org.apache.poi.xssf.usermodel.XSSFPivotTable;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

/**
 *
 * @author irvan
 */
public class MainForm extends javax.swing.JFrame {

    /**
     * Creates new form MainForm
     */
    public MainForm() {
        initComponents();
        //ImageIcon img = new ImageIcon("ict2.png");
        //this.setIconImage(img.getImage());
        this.setIconImage(Toolkit.getDefaultToolkit().getImage(getClass().getResource("ict2.png")));
        this.setExtendedState(this.getExtendedState() | JFrame.MAXIMIZED_BOTH);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jTabbedPane1 = new javax.swing.JTabbedPane();
        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jButton1 = new javax.swing.JButton();
        jCheckBox1 = new javax.swing.JCheckBox();
        jButton2 = new javax.swing.JButton();
        jButton3 = new javax.swing.JButton();
        jLabel16 = new javax.swing.JLabel();
        jButton4 = new javax.swing.JButton();
        jCheckBox2 = new javax.swing.JCheckBox();
        jCheckBox3 = new javax.swing.JCheckBox();
        jTextField1 = new javax.swing.JTextField();
        jPanel2 = new javax.swing.JPanel();
        jLabel3 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jLabel7 = new javax.swing.JLabel();
        jLabel10 = new javax.swing.JLabel();
        jLabel11 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        jLabel13 = new javax.swing.JLabel();
        jLabel8 = new javax.swing.JLabel();
        jLabel9 = new javax.swing.JLabel();
        jLabel14 = new javax.swing.JLabel();
        jLabel19 = new javax.swing.JLabel();
        jPanel3 = new javax.swing.JPanel();
        jLabel12 = new javax.swing.JLabel();
        jLabel15 = new javax.swing.JLabel();
        jLabel18 = new javax.swing.JLabel();
        jLabel20 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("ICT PM Report");
        setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        setMinimumSize(new java.awt.Dimension(1550, 1009));

        jTextArea1.setColumns(20);
        jTextArea1.setLineWrap(true);
        jTextArea1.setRows(5);
        jScrollPane1.setViewportView(jTextArea1);

        jTabbedPane1.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        jPanel1.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        jLabel1.setFont(new java.awt.Font("Segoe UI", 1, 24)); // NOI18N
        jLabel1.setText("File output awr miner");

        jLabel2.setFont(new java.awt.Font("Segoe UI", 0, 14)); // NOI18N
        jLabel2.setText("No file");

        jButton1.setText("Browse");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jCheckBox1.setSelected(true);
        jCheckBox1.setText("Auto Open Excel");

        jButton2.setText("Proses");
        jButton2.setEnabled(false);
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        jButton3.setText("Clear");
        jButton3.setEnabled(false);
        jButton3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton3ActionPerformed(evt);
            }
        });

        jLabel16.setText("File Excel :");

        jButton4.setText("Export To Excel");
        jButton4.setEnabled(false);
        jButton4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton4ActionPerformed(evt);
            }
        });

        jCheckBox2.setSelected(true);
        jCheckBox2.setText("Auto Export Excel");
        jCheckBox2.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jCheckBox2MouseClicked(evt);
            }
        });

        jCheckBox3.setText("Proses All Report");

        jTextField1.setEditable(false);
        jTextField1.setBackground(jLabel2.getBackground());
        jTextField1.setForeground(jLabel2.getForeground());
        jTextField1.setToolTipText("");
        jTextField1.setBorder(null);

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel16)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, 692, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 85, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBox2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBox3)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButton2)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(jButton3)
                        .addGap(12, 12, 12)
                        .addComponent(jButton4)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBox1))
                    .addComponent(jLabel1)
                    .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 841, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel2)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButton1)
                    .addComponent(jCheckBox1)
                    .addComponent(jButton2)
                    .addComponent(jButton3)
                    .addComponent(jButton4)
                    .addComponent(jCheckBox2)
                    .addComponent(jCheckBox3))
                .addGap(18, 18, 18)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel16)
                    .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jPanel2.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        jPanel2.setName(""); // NOI18N

        jLabel3.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        jLabel3.setText("File Info :");

        jLabel5.setText("Host Name");

        jLabel7.setFont(new java.awt.Font("Segoe UI", 0, 18)); // NOI18N
        jLabel7.setText("<hostname>");

        jLabel10.setText("Platform");

        jLabel11.setFont(new java.awt.Font("Segoe UI", 0, 18)); // NOI18N
        jLabel11.setText("<platform>");

        jLabel4.setText("DB Name");

        jLabel6.setFont(new java.awt.Font("Segoe UI", 1, 18)); // NOI18N
        jLabel6.setText("<dbname>");

        jLabel13.setText("AWR Miner Version:");

        jLabel8.setText("Version");

        jLabel9.setFont(new java.awt.Font("Segoe UI", 1, 18)); // NOI18N
        jLabel9.setText("<dbversion>");

        jLabel14.setText("<AWR Miner version>");

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(jLabel3)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(jLabel7)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jLabel11, javax.swing.GroupLayout.PREFERRED_SIZE, 326, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap())
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(jLabel5)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jLabel10)
                        .addGap(286, 286, 286))
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel4)
                            .addComponent(jLabel8))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel6, javax.swing.GroupLayout.PREFERRED_SIZE, 144, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(jPanel2Layout.createSequentialGroup()
                                .addComponent(jLabel9, javax.swing.GroupLayout.PREFERRED_SIZE, 169, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(jLabel19)))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel14, javax.swing.GroupLayout.PREFERRED_SIZE, 177, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel13))
                        .addGap(155, 155, 155))))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel3)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel5)
                    .addComponent(jLabel10))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel11)
                    .addComponent(jLabel7, javax.swing.GroupLayout.Alignment.TRAILING))
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addGap(6, 6, 6)
                        .addComponent(jLabel13, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel14))
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel4)
                            .addComponent(jLabel6, javax.swing.GroupLayout.PREFERRED_SIZE, 28, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jLabel8)
                            .addComponent(jLabel9)
                            .addComponent(jLabel19))))
                .addGap(0, 39, Short.MAX_VALUE))
        );

        jPanel3.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        jLabel12.setIcon(new javax.swing.ImageIcon(getClass().getResource("/pmreport/ict.png"))); // NOI18N
        jLabel12.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        jLabel15.setFont(new java.awt.Font("Arial", 1, 14)); // NOI18N
        jLabel15.setText("Â© B-Wok");
        jLabel15.setToolTipText("");

        jLabel18.setFont(new java.awt.Font("Segoe UI", 1, 24)); // NOI18N
        jLabel18.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel18.setText(" AWR Report App");
        jLabel18.setBorder(new javax.swing.border.LineBorder(new java.awt.Color(0, 0, 0), 1, true));

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jLabel12, javax.swing.GroupLayout.PREFERRED_SIZE, 643, Short.MAX_VALUE)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel18, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel3Layout.createSequentialGroup()
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addComponent(jLabel15)))
                .addContainerGap())
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addComponent(jLabel12)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel18, javax.swing.GroupLayout.PREFERRED_SIZE, 42, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jLabel15)
                .addContainerGap())
        );

        jLabel20.setText("Other Output:");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jTabbedPane1, javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jPanel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel20)
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(jPanel3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jTabbedPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 341, Short.MAX_VALUE)
                .addGap(18, 18, 18)
                .addComponent(jLabel20)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 294, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    DefaultTableModel OS_INFORMATION = new DefaultTableModel(0, 0);
    DefaultTableModel MEMORY = new DefaultTableModel(0, 0);
    DefaultTableModel MEMORY_SGA_ADVICE = new DefaultTableModel(0, 0);
    DefaultTableModel MEMORY_PGA_ADVICE = new DefaultTableModel(0, 0);
    DefaultTableModel SIZE_ON_DISK = new DefaultTableModel(0, 0);
    DefaultTableModel MAIN_METRICS = new DefaultTableModel(0, 0);
    DefaultTableModel DATABASE_PARAMETERS = new DefaultTableModel(0, 0);
    DefaultTableModel AVERAGE_ACTIVE_SESSIONS = new DefaultTableModel(0, 0);
    DefaultTableModel IO_WAIT_HISTOGRAM = new DefaultTableModel(0, 0);
    DefaultTableModel IO_OBJECT_TYPE = new DefaultTableModel(0, 0);
    DefaultTableModel IOSTAT_BY_FUNCTION = new DefaultTableModel(0, 0);
    DefaultTableModel TOP_N_TIMED_EVENTS = new DefaultTableModel(0, 0);
    DefaultTableModel SYSSTAT = new DefaultTableModel(0, 0);
    DefaultTableModel TOP_SQL_SUMMARY = new DefaultTableModel(0, 0);
    DefaultTableModel TOP_SQL_BY_SNAPID = new DefaultTableModel(0, 0);
    DefaultTableModel TABLESPACE = new DefaultTableModel(0, 0);
    DefaultTableModel INVALID_OBJECT = new DefaultTableModel(0, 0);
    DefaultTableModel ANALYZE_TABLE = new DefaultTableModel(0, 0);
    DefaultTableModel RESOURCE_LIMIT = new DefaultTableModel(0, 0);
    DefaultTableModel SWITCH_LOGFILE = new DefaultTableModel(0, 0);
    DefaultTableModel REDO = new DefaultTableModel(0, 0);
    DefaultTableModel SGA = new DefaultTableModel(0, 0);
    DefaultTableModel SGA_INFO = new DefaultTableModel(0, 0);
    DefaultTableModel BUFFER_POOL = new DefaultTableModel(0, 0);
    DefaultTableModel BACKUP = new DefaultTableModel(0, 0);
    DefaultTableModel ASM_DISKGROUP = new DefaultTableModel(0, 0);
    DefaultTableModel ASM_DISK = new DefaultTableModel(0, 0);
    DefaultTableModel RESOURCE_LIMIT_HIST = new DefaultTableModel(0, 0);

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        JFileChooser jfc = new JFileChooser();
        FileFilter filter = new FileNameExtensionFilter("Output File", "out");
        jfc.setFileFilter(filter);
        jfc.showDialog(this, "Open File Output");
        jfc.setVisible(true);
        if (!jfc.getSelectedFile().toString().isEmpty()) {
            String namafile = jfc.getSelectedFile().toString();
            jLabel2.setText(namafile);
            jButton2.setEnabled(true);
        }
        if (jLabel2.getText().equals("No File")) {
            jButton2.setEnabled(false);
        }
    }//GEN-LAST:event_jButton1ActionPerformed

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        jButton2.setEnabled(false);
        if (!jLabel2.getText().equals("No file")) {
            ExecutorService service = Executors.newFixedThreadPool(8);
            service.submit(new Runnable() {
                public void run() {
                    try {
                        String namafile = jLabel2.getText();
                        readUsingBufferedReader(namafile);
                    } catch (IOException ex) {
                        JOptionPane.showMessageDialog(rootPane, ex);
                    } catch (ParseException ex) {
                        JOptionPane.showMessageDialog(rootPane, ex);
                    }
                }
            });
        }
        jButton3.setEnabled(true);
        if (jCheckBox2.isSelected()) {
            jCheckBox1.setSelected(true);
            jButton4.setEnabled(false);
        } else {
            jCheckBox1.setSelected(false);
            jButton4.setEnabled(true);
        }
    }//GEN-LAST:event_jButton2ActionPerformed

    private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton3ActionPerformed
        jLabel6.setText("<dbname>");
        jLabel9.setText("<dbversion>");
        jLabel7.setText("<hostname>");
        jLabel11.setText("<platform>");
        jLabel14.setText("<AWR Miner Version>");
        jTextField1.setText("");
        jLabel2.setText("No file");
        jLabel19.setText("");
        OS_INFORMATION.setRowCount(0);
        MEMORY.setRowCount(0);
        MEMORY_SGA_ADVICE.setRowCount(0);
        MEMORY_PGA_ADVICE.setRowCount(0);
        SIZE_ON_DISK.setRowCount(0);
        MAIN_METRICS.setRowCount(0);
        DATABASE_PARAMETERS.setRowCount(0);
        AVERAGE_ACTIVE_SESSIONS.setRowCount(0);
        IO_WAIT_HISTOGRAM.setRowCount(0);
        IO_OBJECT_TYPE.setRowCount(0);
        IOSTAT_BY_FUNCTION.setRowCount(0);
        TOP_N_TIMED_EVENTS.setRowCount(0);
        SYSSTAT.setRowCount(0);
        TOP_SQL_SUMMARY.setRowCount(0);
        TOP_SQL_BY_SNAPID.setRowCount(0);
        TABLESPACE.setRowCount(0);
        INVALID_OBJECT.setRowCount(0);
        ANALYZE_TABLE.setRowCount(0);
        RESOURCE_LIMIT.setRowCount(0);
        SWITCH_LOGFILE.setRowCount(0);
        REDO.setRowCount(0);
        SGA.setRowCount(0);
        SGA_INFO.setRowCount(0);
        BUFFER_POOL.setRowCount(0);
        BACKUP.setRowCount(0);
        ASM_DISKGROUP.setRowCount(0);
        ASM_DISK.setRowCount(0);
        RESOURCE_LIMIT_HIST.setRowCount(0);
        while (jTabbedPane1.getTabCount() > 0) {
            jTabbedPane1.remove(0);
        }
        jTextArea1.setText("");
        jButton3.setEnabled(false);
        jButton4.setEnabled(false);
        if (jLabel2.getText().equals("No file")) {
            jButton2.setEnabled(false);
        }
        System.gc();
    }//GEN-LAST:event_jButton3ActionPerformed

    private void jButton4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton4ActionPerformed
        JLabel prog = new JLabel();
        prog.setText("Exporting To Excel");
        JProgressBar dpb1 = new JProgressBar(0, 100);
        dpb1.setIndeterminate(true);
        JDialog dlg1 = new JDialog(this, "Exporting To Excel dlg1", true);
        dlg1.add(BorderLayout.CENTER, dpb1);
        dlg1.add(BorderLayout.NORTH, prog);
        dlg1.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE);
        dlg1.setSize(300, 70);
        dlg1.setLocationRelativeTo(this);
        Thread th = new Thread(() -> {
            dlg1.setVisible(true);
        });
        th.start();
        try {
            exporttoxl(jLabel2.getText());
        } catch (IOException ioe) {
            JOptionPane.showMessageDialog(this, ioe);
        } catch (ParseException ex) {
            Logger.getLogger(MainForm.class.getName()).log(Level.SEVERE, null, ex);
        }
        
        dlg1.setVisible(false);
    }//GEN-LAST:event_jButton4ActionPerformed

    private void jCheckBox2MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jCheckBox2MouseClicked
        if (jCheckBox2.isSelected()) {
            if (!jTextField1.getText().isEmpty()) {
                jButton4.setEnabled(false);
            }
        }
    }//GEN-LAST:event_jCheckBox2MouseClicked

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(MainForm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(MainForm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(MainForm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(MainForm.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new MainForm().setVisible(true);
            }
        });
    }

    public void exporttoxl(String filename) throws FileNotFoundException, IOException, ParseException {
        String metriccount;
        int c = MAIN_METRICS.getRowCount() + 1;
        metriccount = String.valueOf(c);
        String filenamewoext = filename.substring(0, filename.lastIndexOf('.'));
        File saveFile = new File(filenamewoext + ".xlsx");
        jTextField1.setText(saveFile.toString());
        FileOutputStream out;
        try (XSSFWorkbook wb = new XSSFWorkbook()) {
            CellStyle cellStyle = wb.createCellStyle();
            CreationHelper createHelper = wb.getCreationHelper();
            cellStyle.setDataFormat(createHelper.createDataFormat().getFormat("dd/mm/yy HH:mm"));
            CellStyle numberstyle = wb.createCellStyle();
            numberstyle.setDataFormat(createHelper.createDataFormat().getFormat("0"));
            //sheet os info
            XSSFSheet osinfo = wb.createSheet("OS Info");
            Row rowCol = osinfo.createRow(0);
            for (int i = 0; i < OS_INFORMATION.getColumnCount(); i++) {
                Cell cell = rowCol.createCell(i);
                cell.setCellValue(OS_INFORMATION.getColumnName(i));
            }
            for (int j = 0; j < OS_INFORMATION.getRowCount(); j++) {
                Row row = osinfo.createRow(j + 1);
                for (int k = 0; k < OS_INFORMATION.getColumnCount(); k++) {
                    Cell cell = row.createCell(k);
                    if (OS_INFORMATION.getValueAt(j, k) != null) {
                        cell.setCellValue(OS_INFORMATION.getValueAt(j, k).toString().trim());
                    }
                }
            }

            //sheet os memory
            XSSFSheet osmemsh = wb.createSheet("OS Memory");
            Row osmemCol = osmemsh.createRow(0);
            for (int i = 0; i < MEMORY.getColumnCount() + 1; i++) {
                if (i < MEMORY.getColumnCount()) {
                    Cell cell = osmemCol.createCell(i);
                    cell.setCellValue(MEMORY.getColumnName(i));
                } else {
                    Cell cell = osmemCol.createCell(i);
                    cell.setCellValue("Tanggal");
                }
            }
            for (int j = 0; j < MEMORY.getRowCount(); j++) {
                Row row = osmemsh.createRow(j + 1);
                String colfor = "LOOKUP(A" + String.valueOf(j + 2) + ",'Main Metric'!A$2:A$" + metriccount + ",'Main Metric'!C$2:C$" + metriccount + ")";
                for (int k = 0; k < MEMORY.getColumnCount() + 1; k++) {
                    if (k < MEMORY.getColumnCount()) {
                        Cell cell = row.createCell(k);
                        if (MEMORY.getValueAt(j, k) != null) {
                            Double data = Double.valueOf(MEMORY.getValueAt(j, k).toString());
                            cell.setCellValue(data);
                        }
                    } else {
                        Cell cell = row.createCell(k);
                        cell.setCellFormula(colfor);
                        cell.setCellStyle(cellStyle);
                    }
                }
            }

            //pivot table osmem
            if (jLabel19.getText().contains("RAC")) {
                XSSFSheet osmem_pvt = wb.createSheet("OS Memory Pivot");
                AreaReference osmemar = new AreaReference("A1:F" + osmemsh.getLastRowNum(), SpreadsheetVersion.EXCEL2007);
                CellReference osmemcr = new CellReference("A1");
                XSSFPivotTable osmempvt = osmem_pvt.createPivotTable(osmemar, osmemcr, osmemsh);
                osmempvt.addRowLabel(5);
                osmempvt.addReportFilter(1);
                osmempvt.addColumnLabel(DataConsolidateFunction.SUM, 2, "SGA");
                osmempvt.addColumnLabel(DataConsolidateFunction.SUM, 3, "PGA");
            }

            //Size on Disk sheet
            XSSFSheet sodsh = wb.createSheet("Size On Disk");
            Row sodCol = sodsh.createRow(0);
            for (int i = 0; i < SIZE_ON_DISK.getColumnCount() + 1; i++) {
                if (i < SIZE_ON_DISK.getColumnCount()) {
                    Cell cell = sodCol.createCell(i);
                    cell.setCellValue(SIZE_ON_DISK.getColumnName(i));
                } else {
                    Cell cell = sodCol.createCell(i);
                    cell.setCellValue("Tanggal");
                }
            }
            for (int j = 0; j < SIZE_ON_DISK.getRowCount(); j++) {
                Row row = sodsh.createRow(j + 1);
                String colfor = "LOOKUP(A" + String.valueOf(j + 2) + ",'Main Metric'!A$2:A$" + metriccount + ",'Main Metric'!C$2:C$" + metriccount + ")";
                for (int k = 0; k < SIZE_ON_DISK.getColumnCount() + 1; k++) {
                    if (k < SIZE_ON_DISK.getColumnCount()) {
                        Cell cell = row.createCell(k);
                        if (SIZE_ON_DISK.getValueAt(j, k) != null) {
                            Double data = Double.valueOf(SIZE_ON_DISK.getValueAt(j, k).toString());
                            cell.setCellValue(data);
                        }
                    } else {
                        Cell cell = row.createCell(k);
                        cell.setCellFormula(colfor);
                        cell.setCellStyle(cellStyle);
                    }
                }
            }

            //sheet main metrics
            XSSFSheet metricssh = wb.createSheet("Main Metric");
            Row metricsCol = metricssh.createRow(0);
            for (int i = 0; i < MAIN_METRICS.getColumnCount(); i++) {
                Cell cell = metricsCol.createCell(i);
                cell.setCellValue(MAIN_METRICS.getColumnName(i));
            }
            for (int j = 0; j < MAIN_METRICS.getRowCount(); j++) {
                Row row = metricssh.createRow(j + 1);
                for (int k = 0; k < MAIN_METRICS.getColumnCount(); k++) {
                    Cell cell = row.createCell(k);
                    if (MAIN_METRICS.getValueAt(j, k) != null) {
                        if (k == 2) {
//                                                    CellStyle cellStyle = wb.createCellStyle();
//                                                    CreationHelper createHelper = wb.getCreationHelper();
//                                                    cellStyle.setDataFormat(createHelper.createDataFormat().getFormat("dd/mm/yy HH:mm"));
                            SimpleDateFormat formatter1 = new SimpleDateFormat("yy/MM/dd HH:mm");
                            Date data = formatter1.parse(MAIN_METRICS.getValueAt(j, k).toString());
                            cell.setCellValue(data);
                            cell.setCellStyle(cellStyle);
                        } else {
                            Double data = Double.valueOf(MAIN_METRICS.getValueAt(j, k).toString());
                            cell.setCellValue(data);
                        }
                    }
                }
            }

            //pivot table main metric
            if (jLabel19.getText().contains("RAC")) {
                XSSFSheet mm_pvt = wb.createSheet("Main Metrics Pivot");
                AreaReference mmar = new AreaReference("A1:AZ" + metricssh.getLastRowNum(), SpreadsheetVersion.EXCEL2007);
                CellReference mmcr = new CellReference("A1");
                XSSFPivotTable mmpvt = mm_pvt.createPivotTable(mmar, mmcr, metricssh);
                mmpvt.addRowLabel(2);
                mmpvt.addReportFilter(3);
                mmpvt.addColumnLabel(DataConsolidateFunction.SUM, 4, "CPU");
                mmpvt.addColumnLabel(DataConsolidateFunction.SUM, 5, "CPU MAX");
            }

            //sheet average active session
            XSSFSheet aassh = wb.createSheet("Average Active Session");
            Row aasCol = aassh.createRow(0);
            for (int i = 0; i < AVERAGE_ACTIVE_SESSIONS.getColumnCount() + 1; i++) {
                if (i < AVERAGE_ACTIVE_SESSIONS.getColumnCount()) {
                    Cell cell = aasCol.createCell(i);
                    cell.setCellValue(AVERAGE_ACTIVE_SESSIONS.getColumnName(i));
                } else {
                    Cell cell = aasCol.createCell(i);
                    cell.setCellValue("Tanggal");
                }
            }
            for (int j = 0; j < AVERAGE_ACTIVE_SESSIONS.getRowCount(); j++) {
                Row row = aassh.createRow(j + 1);
                String colfor = "LOOKUP(A" + String.valueOf(j + 2) + ",'Main Metric'!A$2:A$" + metriccount + ",'Main Metric'!C$2:C$" + metriccount + ")";
                for (int k = 0; k < AVERAGE_ACTIVE_SESSIONS.getColumnCount() + 1; k++) {
                    if (k < AVERAGE_ACTIVE_SESSIONS.getColumnCount()) {
                        Cell cell = row.createCell(k);
                        if (AVERAGE_ACTIVE_SESSIONS.getValueAt(j, k) != null) {
                            if (k == 1) {
                                cell.setCellValue(AVERAGE_ACTIVE_SESSIONS.getValueAt(j, k).toString());
                            } else {
                                Double data = Double.valueOf(AVERAGE_ACTIVE_SESSIONS.getValueAt(j, k).toString());
                                cell.setCellValue(data);
                            }
                        }
                    } else {
                        Cell cell = row.createCell(k);
                        cell.setCellFormula(colfor);
                        cell.setCellStyle(cellStyle);
                    }
                }
            }

            //pivot table aas
            if (AVERAGE_ACTIVE_SESSIONS.getRowCount() > 0) {
                XSSFSheet aas_pvt = wb.createSheet("AAS Pivot");
                AreaReference aasar = new AreaReference("A1:D" + aassh.getLastRowNum(), SpreadsheetVersion.EXCEL2007);
                CellReference aascr = new CellReference("A1");
                XSSFPivotTable pivotTable = aas_pvt.createPivotTable(aasar, aascr, aassh);
                pivotTable.addRowLabel(3);
                pivotTable.addColLabel(1);
                pivotTable.addColumnLabel(DataConsolidateFunction.SUM, 2);
            }

            //sheet tablespace
            XSSFSheet tbssh = wb.createSheet("Table Space");
            Row tbsCol = tbssh.createRow(0);
            for (int i = 0; i < TABLESPACE.getColumnCount(); i++) {
                Cell cell = tbsCol.createCell(i);
                cell.setCellValue(TABLESPACE.getColumnName(i));
            }
            for (int j = 0; j < TABLESPACE.getRowCount(); j++) {
                Row row = tbssh.createRow(j + 1);

                for (int k = 0; k < TABLESPACE.getColumnCount(); k++) {
                    Cell cell = row.createCell(k);
                    if (TABLESPACE.getValueAt(j, k) != null) {
                        cell.setCellValue(TABLESPACE.getValueAt(j, k).toString());
                    }
                }
            }

            //sheet invalid object
            XSSFSheet invalobjsh = wb.createSheet("Invalid Object");
            Row invalobjCol = invalobjsh.createRow(0);
            for (int i = 0; i < INVALID_OBJECT.getColumnCount(); i++) {
                Cell cell = invalobjCol.createCell(i);
                cell.setCellValue(INVALID_OBJECT.getColumnName(i));
            }
            for (int j = 0; j < INVALID_OBJECT.getRowCount(); j++) {
                Row row = invalobjsh.createRow(j + 1);
                for (int k = 0; k < INVALID_OBJECT.getColumnCount(); k++) {
                    Cell cell = row.createCell(k);
                    if (INVALID_OBJECT.getValueAt(j, k) != null) {
                        cell.setCellValue(INVALID_OBJECT.getValueAt(j, k).toString());
                    }
                }
            }

            //sheet resource limit
            XSSFSheet reslimsh = wb.createSheet("Resouce Limit");
            Row reslimCol = reslimsh.createRow(0);
            for (int i = 0; i < RESOURCE_LIMIT.getColumnCount(); i++) {
                Cell cell = reslimCol.createCell(i);
                cell.setCellValue(RESOURCE_LIMIT.getColumnName(i));
            }
            for (int j = 0; j < RESOURCE_LIMIT.getRowCount(); j++) {
                Row row = reslimsh.createRow(j + 1);
                for (int k = 0; k < RESOURCE_LIMIT.getColumnCount(); k++) {
                    Cell cell = row.createCell(k);
                    if (RESOURCE_LIMIT.getValueAt(j, k) != null) {
                        cell.setCellValue(RESOURCE_LIMIT.getValueAt(j, k).toString());
                    }
                }
            }

            //sheet switch log
            XSSFSheet switchlogsh = wb.createSheet("Switch Log");
            Row switchlogCol = switchlogsh.createRow(0);
            for (int i = 0; i < SWITCH_LOGFILE.getColumnCount(); i++) {
                Cell cell = switchlogCol.createCell(i);
                cell.setCellValue(SWITCH_LOGFILE.getColumnName(i));
            }
            for (int j = 0; j < SWITCH_LOGFILE.getRowCount(); j++) {
                Row row = switchlogsh.createRow(j + 1);
                for (int k = 0; k < SWITCH_LOGFILE.getColumnCount(); k++) {
                    Cell cell = row.createCell(k);
                    if (SWITCH_LOGFILE.getValueAt(j, k) != null) {
                        cell.setCellValue(SWITCH_LOGFILE.getValueAt(j, k).toString());
                    }
                }
            }

            //sheet backup
            XSSFSheet backupsh = wb.createSheet("Backup History");
            Row backupCol = backupsh.createRow(0);
            for (int i = 0; i < BACKUP.getColumnCount(); i++) {
                Cell cell = backupCol.createCell(i);
                cell.setCellValue(BACKUP.getColumnName(i));
            }
            for (int j = 0; j < BACKUP.getRowCount(); j++) {
                Row row = backupsh.createRow(j + 1);
                for (int k = 0; k < BACKUP.getColumnCount(); k++) {
                    Cell cell = row.createCell(k);
                    if (BACKUP.getValueAt(j, k) != null) {
                        cell.setCellValue(BACKUP.getValueAt(j, k).toString());
                    }
                }
            }

            //sheet ASM Diskgroup
            XSSFSheet asmdgsh = wb.createSheet("ASM Diskgroup");
            Row asmdgCol = asmdgsh.createRow(0);
            for (int i = 0; i < ASM_DISKGROUP.getColumnCount(); i++) {
                Cell cell = asmdgCol.createCell(i);
                cell.setCellValue(ASM_DISKGROUP.getColumnName(i));
            }
            for (int j = 0; j < ASM_DISKGROUP.getRowCount(); j++) {
                Row row = asmdgsh.createRow(j + 1);
                for (int k = 0; k < ASM_DISKGROUP.getColumnCount(); k++) {
                    Cell cell = row.createCell(k);
                    if (ASM_DISKGROUP.getValueAt(j, k) != null) {
                        cell.setCellValue(ASM_DISKGROUP.getValueAt(j, k).toString());
                    }
                }
            }

            //sheet ASM Disk
            XSSFSheet asmdsh = wb.createSheet("ASM Disk");
            Row asmdCol = asmdsh.createRow(0);
            for (int i = 0; i < ASM_DISK.getColumnCount(); i++) {
                Cell cell = asmdCol.createCell(i);
                cell.setCellValue(ASM_DISK.getColumnName(i));
            }
            for (int j = 0; j < ASM_DISK.getRowCount(); j++) {
                Row row = asmdsh.createRow(j + 1);
                for (int k = 0; k < ASM_DISK.getColumnCount(); k++) {
                    Cell cell = row.createCell(k);
                    if (ASM_DISK.getValueAt(j, k) != null) {
                        cell.setCellValue(ASM_DISK.getValueAt(j, k).toString());
                    }
                }
            }

            //Create Chart
            //OS Memory Chart
            if (MEMORY.getRowCount() > 0) {
                osmemsh.createDrawingPatriarch();
                XSSFDrawing drawing = osmemsh.getDrawingPatriarch();
                XSSFClientAnchor anchor = (XSSFClientAnchor) drawing.createAnchor(0, 0, 0, 0, 6, 1, 21, 25);

                XSSFChart chart = drawing.createChart(anchor);
                chart.setTitleText("OS Memory");
                chart.setTitleOverlay(false);
                XDDFChartLegend legend = chart.getOrAddLegend();
                legend.setPosition(LegendPosition.TOP_RIGHT);
                XDDFCategoryAxis bottomAxis = chart.createCategoryAxis(AxisPosition.BOTTOM);
                bottomAxis.setTitle("Tanngal");
                XDDFValueAxis leftAxis = chart.createValueAxis(AxisPosition.LEFT);
                leftAxis.setTitle("GB");
                if (bottomAxis.hasNumberFormat()) {
                    bottomAxis.setNumberFormat("@");
                }
                if (leftAxis.hasNumberFormat()) {
                    leftAxis.setNumberFormat("#,##0.00");
                }
                XDDFCategoryDataSource tanggal = XDDFDataSourcesFactory.fromStringCellRange(osmemsh, new CellRangeAddress(1, MEMORY.getRowCount(), 5, 5));
                XDDFNumericalDataSource<Double> SGA1 = XDDFDataSourcesFactory
                        .fromNumericCellRange(osmemsh, new CellRangeAddress(1, MEMORY.getRowCount(), 2, 2));
                XDDFNumericalDataSource<Double> PGA = XDDFDataSourcesFactory
                        .fromNumericCellRange(osmemsh, new CellRangeAddress(1, MEMORY.getRowCount(), 3, 3));
                XDDFBarChartData osmemdat = (XDDFBarChartData) chart.createData(ChartTypes.BAR, bottomAxis, leftAxis);
                osmemdat.setBarDirection(BarDirection.COL);
                osmemdat.setBarGrouping(BarGrouping.STACKED);
                XDDFBarChartData.Series series1 = (XDDFBarChartData.Series) osmemdat.addSeries(tanggal, SGA1);
                series1.setTitle("SGA", null);
                XDDFBarChartData.Series series2 = (XDDFBarChartData.Series) osmemdat.addSeries(tanggal, PGA);
                series2.setTitle("PGA", null);
                chart.plot(osmemdat);
            }

//            Size On Disk Chart
            if (SIZE_ON_DISK.getRowCount() > 0) {
                sodsh.createDrawingPatriarch();
                XSSFDrawing soddraw = sodsh.getDrawingPatriarch();
                XSSFClientAnchor sodanchor = (XSSFClientAnchor) soddraw.createAnchor(0, 0, 0, 0, 4, 1, 21, 25);
                XSSFChart sodchart = soddraw.createChart(sodanchor);
                sodchart.setTitleText("Size On Disk");
                sodchart.setTitleOverlay(false);
                XDDFCategoryAxis sodbottomAxis = sodchart.createCategoryAxis(AxisPosition.BOTTOM);
                sodbottomAxis.setTitle("Tanggal");
                XDDFValueAxis sodleftAxis = sodchart.createValueAxis(AxisPosition.LEFT);
                sodleftAxis.setTitle("GB");
                if (sodbottomAxis.hasNumberFormat()) {
                    sodbottomAxis.setNumberFormat("@");
                }
                if (sodleftAxis.hasNumberFormat()) {
                    sodleftAxis.setNumberFormat("#,##0.00");
                }
                XDDFCategoryDataSource sodtanggal = XDDFDataSourcesFactory.fromStringCellRange(sodsh, new CellRangeAddress(1, SIZE_ON_DISK.getRowCount(), 2, 2));
                XDDFNumericalDataSource<Double> Size = XDDFDataSourcesFactory
                        .fromNumericCellRange(sodsh, new CellRangeAddress(1, SIZE_ON_DISK.getRowCount(), 1, 1));
                XDDFBarChartData soddat = (XDDFBarChartData) sodchart.createData(ChartTypes.BAR, sodbottomAxis, sodleftAxis);
                soddat.setBarDirection(BarDirection.COL);
                soddat.setGapWidth(50);
                soddat.setVaryColors(false);
                XDDFBarChartData.Series sodser = (XDDFBarChartData.Series) soddat.addSeries(sodtanggal, Size);
                sodser.setTitle("SIZE", null);
                sodchart.plot(soddat);
            }

            //OS CPU Chart (main metric)
            if (MAIN_METRICS.getRowCount() > 0) {
                metricssh.createDrawingPatriarch();
                XSSFDrawing mmdraw = metricssh.getDrawingPatriarch();
                XSSFClientAnchor mmanchor = (XSSFClientAnchor) mmdraw.createAnchor(0, 0, 0, 0, 1, 5, 21, 25);
                XSSFChart mmchart = mmdraw.createChart(mmanchor);
                mmchart.setTitleText("OS CPU");
                mmchart.setTitleOverlay(false);
                XDDFChartLegend mmlegend = mmchart.getOrAddLegend();
                mmlegend.setPosition(LegendPosition.TOP_RIGHT);
                XDDFCategoryAxis mmbottomAxis = mmchart.createCategoryAxis(AxisPosition.BOTTOM);
                mmbottomAxis.setTitle("Tanggal");
                XDDFValueAxis mmleftAxis = mmchart.createValueAxis(AxisPosition.LEFT);
                mmleftAxis.setTitle("Percent");
                if (mmbottomAxis.hasNumberFormat()) {
                    mmbottomAxis.setNumberFormat("@");
                }
                if (mmleftAxis.hasNumberFormat()) {
                    mmleftAxis.setNumberFormat("#,##0.00");
                }
                XDDFCategoryDataSource mmtanggal = XDDFDataSourcesFactory.fromStringCellRange(metricssh, new CellRangeAddress(1, MAIN_METRICS.getRowCount(), 2, 2));
                XDDFNumericalDataSource<Double> cpu = XDDFDataSourcesFactory
                        .fromNumericCellRange(metricssh, new CellRangeAddress(1, MAIN_METRICS.getRowCount(), 4, 4));
                XDDFNumericalDataSource<Double> cpu_tot = XDDFDataSourcesFactory
                        .fromNumericCellRange(metricssh, new CellRangeAddress(1, MAIN_METRICS.getRowCount(), 5, 5));
                XDDFLineChartData mmdat = (XDDFLineChartData) mmchart.createData(ChartTypes.LINE, mmbottomAxis, mmleftAxis);
                XDDFLineChartData.Series mmser1 = (XDDFLineChartData.Series) mmdat.addSeries(mmtanggal, cpu);
                mmser1.setTitle("Average CPU", null);
                mmser1.setSmooth(true);
                mmser1.setMarkerStyle(MarkerStyle.NONE);
                XDDFLineChartData.Series mmser2 = (XDDFLineChartData.Series) mmdat.addSeries(mmtanggal, cpu_tot);
                mmser2.setTitle("CPU Max", null);
                mmser2.setSmooth(true);
                mmser2.setMarkerStyle(MarkerStyle.NONE);
                mmchart.plot(mmdat);
            }

            //write the file
            out = new FileOutputStream(new File(saveFile.toString()));

            wb.write(out);
        }
        out.close();
        if (jCheckBox1.isSelected()) {

            openFile(saveFile.toString());

        }
    }

    public void openFile(String file) throws IOException {

        File path = new File(file);
        Desktop.getDesktop().open(path);

    }

    public void readUsingBufferedReader(String fileName) throws IOException, ParseException {
        JLabel pros = new JLabel();
        JLabel prog = new JLabel();
        prog.setText("Prosessing...");
        final JDialog dlg = new JDialog(this, "Progress Dialog", true);
        JProgressBar dpb = new JProgressBar(0, 500);
        dpb.setIndeterminate(true);
        dlg.add(BorderLayout.SOUTH, dpb);
        dlg.add(BorderLayout.NORTH, prog);
        dlg.add(BorderLayout.CENTER, pros);
        dlg.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE);
        dlg.setSize(300, 90);
        dlg.setLocationRelativeTo(this);
        Thread t = new Thread(() -> {
            dlg.setVisible(true);
        });
        t.start();
        File file = new File(jLabel2.getText());
        try (FileReader fr = new FileReader(file); // read file line by line
                 BufferedReader br = new BufferedReader(fr)) {
            String line;
            String pattern = "^";
            int lineNum = 0;
            int linebag = 0;
            while (jTabbedPane1.getTabCount() > 0) {
                jTabbedPane1.remove(0);
            }
            jTextArea1.setText("");
            String bagian = "kosong";
            Pattern p;
            String[] coll;

            while ((line = br.readLine()) != null) {
                // process the line
                lineNum++;
                String trim = line.trim();
                if (line.contains("~~")) {
                    if (line.contains("~~BEGIN")) {
                        switch (line) {
                            case "~~BEGIN-OS-INFORMATION~~":
                                bagian = "OS Info";
                                break;
                            case "~~BEGIN-MEMORY~~":
                                bagian = "OS Memory";
                                break;
                            case "~~BEGIN-MEMORY-SGA-ADVICE~~":
                                if (jCheckBox3.isSelected()) {
                                    bagian = "SGA Advisory";
                                }
                                break;

                            case "~~BEGIN-MEMORY-PGA-ADVICE~~":
                                if (jCheckBox3.isSelected()) {
                                    bagian = "PGA Advisory";
                                }
                                break;

                            case "~~BEGIN-SIZE-ON-DISK~~":
                                bagian = "Size On Disk";
                                break;
                            case "~~BEGIN-MAIN-METRICS~~":
                                bagian = "Main Metric";
                                break;
                            case "~~BEGIN-DATABASE-PARAMETERS~~":
                                if (jCheckBox3.isSelected()) {
                                    bagian = "Parameters";
                                }
                                break;

                            case "~~BEGIN-AVERAGE-ACTIVE-SESSIONS~~":
                                bagian = "Average Active Sessions";
                                break;
                            case "~~BEGIN-IO-WAIT-HISTOGRAM~~":
                                if (jCheckBox3.isSelected()) {
                                    bagian = "IO Wait Histogram";
                                }
                                break;
                            case "~~BEGIN-IO-OBJECT-TYPE~~":
                                if (jCheckBox3.isSelected()) {
                                    bagian = "IO by Object Type";
                                }
                                break;
                            case "~~BEGIN-IOSTAT-BY-FUNCTION~~":
                                if (jCheckBox3.isSelected()) {
                                    bagian = "IOSTAT by Function";
                                }
                                break;
                            case "~~BEGIN-TOP-N-TIMED-EVENTS~~":
                                if (jCheckBox3.isSelected()) {
                                    bagian = "TOP Timed Evenets";
                                }
                                break;
                            case "~~BEGIN-SYSSTAT~~":
                                if (jCheckBox3.isSelected()) {
                                    bagian = "SYSSTAT";
                                }
                                break;
                            case "~~BEGIN-TOP-SQL-SUMMARY~~":
                                if (jCheckBox3.isSelected()) {
                                    bagian = "TOP SQL Summary";
                                }
                                break;
                            case "~~BEGIN-TOP-SQL-BY-SNAPID~~":
                                if (jCheckBox3.isSelected()) {
                                    bagian = "TOP SQL by SNAPID";
                                }
                                break;
                            case "~~BEGIN-TABLESPACE~~":
                                bagian = "Tablespace";
                                break;
                            case "~~BEGIN-INVALID-OBJECT~~":
                                bagian = "Invalid Object";
                                break;
                            case "~~BEGIN-ANALYZE-TABLE~~":
                                if (jCheckBox3.isSelected()) {
                                    bagian = "Analyze Table";
                                }
                                break;
                            case "~~BEGIN-RESOURCE-LIMIT~~":
                                bagian = "Resource Limit";
                                break;
                            case "~~BEGIN-SWITCH-LOGFILE~~":
                                bagian = "Switch Log Frequency Map";
                                break;
                            case "~~BEGIN REDO~~":
                                if (jCheckBox3.isSelected()) {
                                    bagian = "REDO LOG Info";
                                }
                                break;
                            case "~~BEGIN-SGA~~":
                                if (jCheckBox3.isSelected()) {
                                    bagian = "SGA";
                                }
                                break;
                            case "~~BEGIN-SGA-INFO~~":
                                if (jCheckBox3.isSelected()) {
                                    bagian = "SGA Info";
                                }
                                break;
                            case "~~BEGIN-BUFFER-POOL~~":
                                if (jCheckBox3.isSelected()) {
                                    bagian = "Buffer Pool";
                                }
                                break;
                            case "~~BEGIN-BACKUP~~":
                                bagian = "Backup History";
                                break;
                            case "~~BEGIN-ASM-DISKGROUP~~":
                                bagian = "ASM Diskgroup";
                                break;
                            case "~~BEGIN-ASM-DISK~~":
                                bagian = "ASM Disk";
                                break;
                            case "~~BEGIN-RESOURCE-LIMIT-HIST~~":
                                if (jCheckBox3.isSelected()) {
                                    bagian = "Resource Limit History";
                                }
                                break;
                        }
                    } else {
                        if (line.contains("~~END")) {
                            switch (bagian) {
                                case "OS Info":
                                    pros.setText("Prosessing " + bagian + " ...");
                                    JTable osinfo;
                                    osinfo = new JTable(OS_INFORMATION);
                                    JScrollPane scrollPane = new JScrollPane(osinfo,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
                                    jTabbedPane1.addTab(bagian, scrollPane);
                                    break;
                                case "OS Memory":
                                    pros.setText("Prosessing " + bagian + " ...");
                                    JTable osmem;
                                    JPanel osmempan = new JPanel();
                                    osmempan.setLayout(new BoxLayout(osmempan, BoxLayout.Y_AXIS));
                                    osmem = new JTable(MEMORY);
                                    JButton osmemgraph = new JButton("Show Graph");
                                    JScrollPane osmemsc = new JScrollPane(osmem,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);  
                                    osmempan.add(osmemsc);
                                    osmempan.add(osmemgraph);                                    
                                    jTabbedPane1.addTab(bagian, osmempan);                                    
                                    break;
                                case "SGA Advisory":
                                    pros.setText("Prosessing " + bagian + " ...");
                                    JTable sgaadv;
                                    sgaadv = new JTable(MEMORY_SGA_ADVICE);
                                    JScrollPane sgaadvsc = new JScrollPane(sgaadv);
                                    jTabbedPane1.addTab(bagian, sgaadvsc);
                                    break;
                                case "PGA Advisory":
                                    pros.setText("Prosessing " + bagian + " ...");
                                    JTable pgaadv;
                                    pgaadv = new JTable(MEMORY_PGA_ADVICE);
                                    JScrollPane pgaadvsc = new JScrollPane(pgaadv);
                                    jTabbedPane1.addTab(bagian, pgaadvsc);
                                    break;
                                case "Size On Disk":
                                    pros.setText("Prosessing " + bagian + " ...");
                                    JTable sod;
                                    sod = new JTable(SIZE_ON_DISK);
                                    JScrollPane sodsc = new JScrollPane(sod);
                                    jTabbedPane1.addTab(bagian, sodsc);

                                    break;
                                case "Main Metric":
                                    pros.setText("Prosessing " + bagian + " ...");
                                    JTable metrics;
                                    metrics = new JTable(MAIN_METRICS);
                                    metrics.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
                                    //metrics.getColumnModel().getColumn(0).setMinWidth(20);                                    
                                    JScrollPane metricssc = new JScrollPane(metrics,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
                                    //metrics.setAutoResizeMode(AUTO_RESIZE_ALL_COLUMNS);
                                    setResizable(false);
                                    jTabbedPane1.addTab(bagian, metricssc);
                                    
                                    break;
                                case "Parameters":
                                    pros.setText("Prosessing " + bagian + " ...");
                                    JTable param;
                                    param = new JTable(DATABASE_PARAMETERS);
                                    JScrollPane paramsc = new JScrollPane(param);
                                    jTabbedPane1.addTab(bagian, paramsc);

                                    break;
                                case "Average Active Sessions":
                                    pros.setText("Prosessing " + bagian + " ...");
                                    JTable aas;
                                    aas = new JTable(AVERAGE_ACTIVE_SESSIONS);
                                    JScrollPane aassc = new JScrollPane(aas);
                                    jTabbedPane1.addTab(bagian, aassc);

                                    break;
                                case "IO Wait Histogram":
                                    pros.setText("Prosessing " + bagian + " ...");
                                    JTable iohist;
                                    iohist = new JTable(IO_WAIT_HISTOGRAM);
                                    JScrollPane iohistsc = new JScrollPane(iohist);
                                    jTabbedPane1.addTab(bagian, iohistsc);

                                    break;
                                case "IO by Object Type":
                                    pros.setText("Prosessing " + bagian + " ...");
                                    JTable ioobjt;
                                    ioobjt = new JTable(IO_OBJECT_TYPE);
                                    JScrollPane ioobjtsc = new JScrollPane(ioobjt);
                                    jTabbedPane1.addTab(bagian, ioobjtsc);

                                    break;
                                case "IOSTAT by Function":
                                    pros.setText("Prosessing " + bagian + " ...");
                                    JTable iofunc;
                                    iofunc = new JTable(IOSTAT_BY_FUNCTION);
                                    JScrollPane iofuncsc = new JScrollPane(iofunc);
                                    jTabbedPane1.addTab(bagian, iofuncsc);

                                    break;
                                case "TOP Timed Evenets":
                                    pros.setText("Prosessing " + bagian + " ...");
                                    JTable TTE;
                                    TTE = new JTable(TOP_N_TIMED_EVENTS);
                                    JScrollPane TTEsc = new JScrollPane(TTE);
                                    jTabbedPane1.addTab(bagian, TTEsc);

                                    break;
                                case "SYSSTAT":
                                    pros.setText("Prosessing " + bagian + " ...");
                                    JTable sysstat;
                                    sysstat = new JTable(SYSSTAT);
                                    JScrollPane sysstatsc = new JScrollPane(sysstat);
                                    jTabbedPane1.addTab(bagian, sysstatsc);

                                    break;
                                case "TOP SQL Summary":
                                    pros.setText("Prosessing " + bagian + " ...");
                                    JTable tsqls;
                                    tsqls = new JTable(TOP_SQL_SUMMARY);
                                    JScrollPane tsqlssc = new JScrollPane(tsqls);
                                    jTabbedPane1.addTab(bagian, tsqlssc);

                                    break;
                                case "TOP SQL by SNAPID":
                                    pros.setText("Prosessing " + bagian + " ...");
                                    JTable tsql;
                                    tsql = new JTable(TOP_SQL_BY_SNAPID);
                                    JScrollPane tsqlsc = new JScrollPane(tsql);
                                    jTabbedPane1.addTab(bagian, tsqlsc);

                                    break;
                                case "Tablespace":
                                    pros.setText("Prosessing " + bagian + " ...");
                                    JTable tbs;
                                    tbs = new JTable(TABLESPACE);
                                    JScrollPane tbssc = new JScrollPane(tbs);
                                    jTabbedPane1.addTab(bagian, tbssc);

                                    break;
                                case "Invalid Object":
                                    pros.setText("Prosessing " + bagian + " ...");
                                    JTable invalobj;
                                    invalobj = new JTable(INVALID_OBJECT);
                                    JScrollPane invalobjsc = new JScrollPane(invalobj);
                                    jTabbedPane1.addTab(bagian, invalobjsc);

                                    break;
                                case "Analyze Table":
                                    pros.setText("Prosessing " + bagian + " ...");
                                    JTable analyze;
                                    analyze = new JTable(ANALYZE_TABLE);
                                    JScrollPane analyzesc = new JScrollPane(analyze);
                                    jTabbedPane1.addTab(bagian, analyzesc);

                                    break;
                                case "Resource Limit":
                                    pros.setText("Prosessing " + bagian + " ...");
                                    JTable reslim;
                                    reslim = new JTable(RESOURCE_LIMIT);
                                    JScrollPane reslimsc = new JScrollPane(reslim);
                                    jTabbedPane1.addTab(bagian, reslimsc);

                                    break;
                                case "Switch Log Frequency Map":
                                    pros.setText("Prosessing " + bagian + " ...");
                                    JTable switchlog;
                                    switchlog = new JTable(SWITCH_LOGFILE);
                                    JScrollPane switchlogsc = new JScrollPane(switchlog, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);                                    
                                    jTabbedPane1.addTab(bagian, switchlogsc);

                                    break;
                                case "REDO LOG Info":
                                    pros.setText("Prosessing " + bagian + " ...");
                                    JTable redo;
                                    redo = new JTable(REDO);
                                    JScrollPane redosc = new JScrollPane(redo);
                                    jTabbedPane1.addTab(bagian, redosc);

                                    break;
                                case "SGA":
                                    pros.setText("Prosessing " + bagian + " ...");
                                    JTable sga;
                                    sga = new JTable(SGA);
                                    JScrollPane sgasc = new JScrollPane(sga);
                                    jTabbedPane1.addTab(bagian, sgasc);

                                    break;
                                case "SGA Info":
                                    pros.setText("Prosessing " + bagian + " ...");
                                    JTable sgai;
                                    sgai = new JTable(SGA_INFO);
                                    JScrollPane sgaisc = new JScrollPane(sgai);
                                    jTabbedPane1.addTab(bagian, sgaisc);

                                    break;
                                case "Buffer Pool":
                                    pros.setText("Prosessing " + bagian + " ...");
                                    JTable buffpool;
                                    buffpool = new JTable(BUFFER_POOL);
                                    JScrollPane buffpoolsc = new JScrollPane(buffpool);
                                    jTabbedPane1.addTab(bagian, buffpoolsc);

                                    break;
                                case "Backup History":
                                    pros.setText("Prosessing " + bagian + " ...");
                                    JTable backup;
                                    backup = new JTable(BACKUP);
                                    JScrollPane backupsc = new JScrollPane(backup);
                                    jTabbedPane1.addTab(bagian, backupsc);

                                    break;
                                case "ASM Diskgroup":
                                    pros.setText("Prosessing " + bagian + " ...");
                                    JTable asmdg;
                                    asmdg = new JTable(ASM_DISKGROUP);
                                    JScrollPane asmdgsc = new JScrollPane(asmdg);
                                    jTabbedPane1.addTab(bagian, asmdgsc);

                                    break;
                                case "ASM Disk":
                                    pros.setText("Prosessing " + bagian + " ...");
                                    JTable asmd;
                                    asmd = new JTable(ASM_DISK);
                                    JScrollPane asmdsc = new JScrollPane(asmd);
                                    jTabbedPane1.addTab(bagian, asmdsc);

                                    break;

                                case "Resource Limit History":
                                    pros.setText("Prosessing " + bagian + " ...");
                                    JTable relilimhist;
                                    relilimhist = new JTable(RESOURCE_LIMIT_HIST);
                                    JScrollPane relilimhistsc = new JScrollPane(relilimhist);
                                    jTabbedPane1.addTab(bagian, relilimhistsc);

                                    break;
                            }
                            bagian = "kosong";
                            linebag = 0;
                        }
                    }
                } else {
                    switch (bagian) {
                        case "OS Info":
                            pros.setText("Extracting data " + bagian + "...");
                            linebag++;
                            if (linebag == 1) {
                                String[] kolom = trim.split("\\s+");
                                OS_INFORMATION.setColumnIdentifiers(kolom);
                            }
                            if (linebag == 2) {
                                int lengh;
                                pattern = "^";
                                String[] colpat = line.split("\\s+");
                                for (int i = 0; i < colpat.length - 1; i++) {
                                    lengh = colpat[i].length();
                                    pattern = pattern + "(.{" + Integer.toString(lengh) + "})";
                                }
                                pattern = pattern + "(.*)";
                            }
                            if (linebag > 2) {
                                List<String> data1;
                                data1 = new ArrayList<>();
                                p = Pattern.compile(pattern);
                                Matcher matcher = p.matcher(line);
                                if (matcher.matches()) {
                                    for (int i = 1; i <= matcher.groupCount(); i++) {
                                        data1.add(matcher.group(i).trim());
                                    }
                                }
                                coll = data1.toArray(new String[0]);
                                OS_INFORMATION.addRow(coll);
                                if (coll[0].equals("DB_NAME")) {
                                    jLabel6.setText(coll[1]);
                                }
                                if (coll[0].equals("VERSION")) {
                                    jLabel9.setText(coll[1]);
                                }
                                if (coll[0].equals("!PLATFORM_NAME")) {
                                    jLabel11.setText(coll[1]);
                                }
                                if (coll[0].equals("HOSTS")) {
                                    jLabel7.setText(coll[1]);
                                }
                                if (coll[0].equals("AWR_MINER_VER")) {
                                    jLabel14.setText(coll[1]);
                                }
                                if (coll[0].equals("INSTANCES")) {
                                    if (!coll[1].equals("1")) {
                                        jLabel19.setText("RAC");
                                    } else {
                                        jLabel19.setText("");
                                    }
                                }
                            }
                            break;
                        case "OS Memory":
                            pros.setText("Extracting data " + bagian + "...");
                            linebag++;
                            if (linebag == 2) {
                                String[] OSM_Kol = trim.split("\\s+");
                                for (int i = 0; i < OSM_Kol.length; i++) {
                                    OSM_Kol[i] = OSM_Kol[i].replaceAll("[^\\w]", "");
                                }
                                MEMORY.setColumnIdentifiers(OSM_Kol);
                            }
                            if (linebag == 3) {
                                int lengh;
                                pattern = "^";
                                String[] colpat = line.split("\\s+");
                                for (int i = 0; i < colpat.length - 1; i++) {
                                    lengh = colpat[i].length() + 1;
                                    pattern = pattern + "(.{" + Integer.toString(lengh) + "})";
                                }
                                pattern = pattern + "(.*)";
                            }
                            if (linebag > 3) {
                                if (!trim.isEmpty()) {
                                    String[] osmem_data;
                                    List<String> data1;
                                    data1 = new ArrayList<>();
                                    p = Pattern.compile(pattern);
                                    Matcher matcher = p.matcher(line);
                                    if (matcher.matches()) {
                                        for (int i = 1; i <= matcher.groupCount(); i++) {
                                            data1.add(matcher.group(i).trim());
                                        }
                                    }
                                    osmem_data = data1.toArray(new String[0]);
                                    MEMORY.addRow(osmem_data);
                                } else {
                                    break;
                                }
                            }
                            break;

                        case "SGA Advisory":
                            pros.setText("Extracting data " + bagian + "...");
                            linebag++;
                            if (linebag == 2) {
                                String[] SGAADV_Kol = trim.split("\\s+");
                                MEMORY_SGA_ADVICE.setColumnIdentifiers(SGAADV_Kol);
                            }
                            if (linebag == 3) {
                                int lengh;
                                pattern = "^";
                                String[] colpat = line.split("\\s+");
                                for (int i = 0; i < colpat.length - 1; i++) {
                                    lengh = colpat[i].length() + 1;
                                    pattern = pattern + "(.{" + Integer.toString(lengh) + "})";
                                }
                                pattern = pattern + "(.*)";
                            }
                            if (linebag > 3) {
                                if (!trim.isEmpty()) {
                                    if (!trim.isEmpty()) {
                                        ArrayList<String> output = new ArrayList<>();
                                        p = Pattern.compile(pattern);
                                        Matcher matcher = p.matcher(line);
                                        if (matcher.matches()) {
                                            for (int i = 1; i <= matcher.groupCount(); i++) {
                                                output.add(matcher.group(i).trim());
                                            }
                                        }
                                        String[] osmem_data = new String[output.size()];
                                        output.toArray(osmem_data);
                                        MEMORY_SGA_ADVICE.addRow(osmem_data);
                                    } else {
                                        break;
                                    }
                                }
                            }
                            break;
                        case "PGA Advisory":
                            pros.setText("Extracting data " + bagian + "...");
                            linebag++;
                            if (linebag == 2) {
                                String[] SGAADV_Kol = trim.split("\\s+");
                                MEMORY_PGA_ADVICE.setColumnIdentifiers(SGAADV_Kol);
                            }
                            if (linebag == 3) {
                                int lengh;
                                pattern = "^";
                                String[] colpat = line.split("\\s+");
                                for (int i = 0; i < colpat.length - 1; i++) {
                                    lengh = colpat[i].length() + 1;
                                    pattern = pattern + "(.{" + Integer.toString(lengh) + "})";
                                }
                                pattern = pattern + "(.*)";
                            }
                            if (linebag > 3) {
                                if (!trim.isEmpty()) {
                                    ArrayList<String> output = new ArrayList<>();
                                    p = Pattern.compile(pattern);
                                    Matcher matcher = p.matcher(line);
                                    if (matcher.matches()) {
                                        for (int i = 1; i <= matcher.groupCount(); i++) {
                                            output.add(matcher.group(i).trim());
                                        }
                                    }
                                    String[] osmem_data = new String[output.size()];
                                    output.toArray(osmem_data);
                                    MEMORY_PGA_ADVICE.addRow(osmem_data);
                                } else {
                                    break;
                                }
                            }
                            break;
                        case "Size On Disk":
                            pros.setText("Extracting data " + bagian + "...");
                            linebag++;
                            if (linebag == 2) {
                                String[] SGAADV_Kol = trim.split("\\s+");
                                SIZE_ON_DISK.setColumnIdentifiers(SGAADV_Kol);
                            }
                            if (linebag == 3) {
                                int lengh;
                                pattern = "^";
                                String[] colpat = line.split("\\s+");
                                for (int i = 0; i < colpat.length - 1; i++) {
                                    lengh = colpat[i].length() + 1;
                                    pattern = pattern + "(.{" + Integer.toString(lengh) + "})";
                                }
                                pattern = pattern + "(.*)";
                            }
                            if (linebag > 3) {
                                if (!trim.isEmpty()) {
                                    ArrayList<String> output = new ArrayList<>();
                                    p = Pattern.compile(pattern);
                                    Matcher matcher = p.matcher(line);
                                    if (matcher.matches()) {
                                        for (int i = 1; i <= matcher.groupCount(); i++) {
                                            output.add(matcher.group(i).trim());
                                        }
                                    }
                                    String[] osmem_data = new String[output.size()];
                                    output.toArray(osmem_data);
                                    SIZE_ON_DISK.addRow(osmem_data);
                                } else {
                                    break;
                                }
                            }
                            break;
                        case "Main Metric":
                            pros.setText("Extracting data " + bagian + "...");
                            linebag++;
                            if (linebag == 2) {
                                String[] SGAADV_Kol = trim.split("\\s+");
                                MAIN_METRICS.setColumnIdentifiers(SGAADV_Kol);
                            }
                            if (linebag == 3) {
                                int lengh;
                                pattern = "^";
                                String[] colpat = line.split("\\s+");
                                for (int i = 0; i < colpat.length - 1; i++) {
                                    lengh = colpat[i].length() + 1;
                                    pattern = pattern + "(.{" + Integer.toString(lengh) + "})";
                                }
                                pattern = pattern + "(.*)";
                            }
                            if (linebag > 3) {
                                if (!trim.isEmpty()) {
                                    ArrayList<String> output = new ArrayList<>();
                                    p = Pattern.compile(pattern);
                                    Matcher matcher = p.matcher(line);
                                    if (matcher.matches()) {
                                        for (int i = 1; i <= matcher.groupCount(); i++) {
                                            output.add(matcher.group(i).trim());
                                        }
                                    }
                                    String[] osmem_data = new String[output.size()];
                                    output.toArray(osmem_data);
                                    MAIN_METRICS.addRow(osmem_data);
                                } else {
                                    break;
                                }
                            }

                            break;
                        case "Parameters":
                            pros.setText("Extracting data " + bagian + "...");
                            linebag++;
                            if (linebag == 2) {
                                String[] SGAADV_Kol = trim.split("\\s+");
                                DATABASE_PARAMETERS.setColumnIdentifiers(SGAADV_Kol);
                            }
                            if (linebag == 3) {
                                int lengh;
                                pattern = "^";
                                String[] colpat = line.split("\\s+");
                                for (int i = 0; i < colpat.length - 1; i++) {
                                    lengh = colpat[i].length() + 1;
                                    pattern = pattern + "(.{" + Integer.toString(lengh) + "})";
                                }
                                pattern = pattern + "(.*)";
                            }
                            if (linebag > 3) {
                                String[] osmem_data;
                                List<String> data1;
                                data1 = new ArrayList<>();
                                p = Pattern.compile(pattern);
                                Matcher matcher = p.matcher(line);
                                if (matcher.matches()) {
                                    for (int i = 1; i <= matcher.groupCount(); i++) {
                                        data1.add(matcher.group(i).trim());
                                    }
                                }
                                if (!matcher.matches()) {
                                    data1.add(line);
                                }
                                osmem_data = data1.toArray(new String[0]);
                                DATABASE_PARAMETERS.addRow(osmem_data);
                            }
                            break;
                        case "Average Active Sessions":
                            pros.setText("Extracting data " + bagian + "...");
                            linebag++;
                            if (linebag == 2) {
                                String[] SGAADV_Kol = trim.split("\\s+");
                                AVERAGE_ACTIVE_SESSIONS.setColumnIdentifiers(SGAADV_Kol);
                            }
                            if (linebag == 3) {
                                int lengh;
                                pattern = "^";
                                String[] colpat = line.split("\\s+");
                                for (int i = 0; i < colpat.length - 1; i++) {
                                    lengh = colpat[i].length() + 1;
                                    pattern = pattern + "(.{" + Integer.toString(lengh) + "})";
                                }
                                pattern = pattern + "(.*)";
                            }
                            if (linebag > 3) {
                                if (!trim.isEmpty()) {
                                    ArrayList<String> output = new ArrayList<>();
                                    p = Pattern.compile(pattern);
                                    Matcher matcher = p.matcher(line);
                                    if (matcher.matches()) {
                                        for (int i = 1; i <= matcher.groupCount(); i++) {
                                            output.add(matcher.group(i).trim());
                                        }
                                    }
                                    String[] osmem_data = new String[output.size()];
                                    output.toArray(osmem_data);
                                    AVERAGE_ACTIVE_SESSIONS.addRow(osmem_data);
                                } else {
                                    break;
                                }
                            }
                            break;
                        case "IO Wait Histogram":
                            pros.setText("Extracting data " + bagian + "...");
                            linebag++;
                            if (linebag == 2) {
                                String[] SGAADV_Kol = trim.split("\\s+");
                                IO_WAIT_HISTOGRAM.setColumnIdentifiers(SGAADV_Kol);
                            }
                            if (linebag == 3) {
                                int lengh;
                                pattern = "^";
                                String[] colpat = line.split("\\s+");
                                for (int i = 0; i < colpat.length - 1; i++) {
                                    lengh = colpat[i].length() + 1;
                                    pattern = pattern + "(.{" + Integer.toString(lengh) + "})";
                                }
                                pattern = pattern + "(.*)";
                            }
                            if (linebag > 3) {
                                if (!trim.isEmpty()) {
                                    ArrayList<String> output = new ArrayList<>();
                                    p = Pattern.compile(pattern);
                                    Matcher matcher = p.matcher(line);
                                    if (matcher.matches()) {
                                        for (int i = 1; i <= matcher.groupCount(); i++) {
                                            output.add(matcher.group(i).trim());
                                        }
                                    }
                                    String[] osmem_data = new String[output.size()];
                                    output.toArray(osmem_data);
                                    IO_WAIT_HISTOGRAM.addRow(osmem_data);
                                } else {
                                    break;
                                }
                            }
                            break;
                        case "IO by Object Type":
                            pros.setText("Extracting data " + bagian + "...");
                            linebag++;
                            if (linebag == 2) {
                                String[] SGAADV_Kol = trim.split("\\s+");
                                IO_OBJECT_TYPE.setColumnIdentifiers(SGAADV_Kol);
                            }
                            if (linebag == 3) {
                                int lengh;
                                pattern = "^";
                                String[] colpat = line.split("\\s+");
                                for (int i = 0; i < colpat.length - 1; i++) {
                                    lengh = colpat[i].length() + 1;
                                    pattern = pattern + "(.{" + Integer.toString(lengh) + "})";
                                }
                                pattern = pattern + "(.*)";
                            }
                            if (linebag > 3) {
                                if (!trim.isEmpty()) {
                                    ArrayList<String> output = new ArrayList<>();
                                    p = Pattern.compile(pattern);
                                    Matcher matcher = p.matcher(line);
                                    if (matcher.matches()) {
                                        for (int i = 1; i <= matcher.groupCount(); i++) {
                                            output.add(matcher.group(i).trim());
                                        }
                                    }
                                    String[] osmem_data = new String[output.size()];
                                    output.toArray(osmem_data);
                                    IO_OBJECT_TYPE.addRow(osmem_data);
                                } else {
                                    break;
                                }
                            }
                            break;
                        case "IOSTAT by Function":
                            pros.setText("Extracting data " + bagian + "...");
                            linebag++;
                            if (linebag == 2) {
                                String[] SGAADV_Kol = trim.split("\\s+");
                                IOSTAT_BY_FUNCTION.setColumnIdentifiers(SGAADV_Kol);
                            }
                            if (linebag == 3) {
                                int lengh;
                                pattern = "^";
                                String[] colpat = line.split("\\s+");
                                for (int i = 0; i < colpat.length - 1; i++) {
                                    lengh = colpat[i].length() + 1;
                                    pattern = pattern + "(.{" + Integer.toString(lengh) + "})";
                                }
                                pattern = pattern + "(.*)";
                            }
                            if (linebag > 3) {
                                if (!trim.isEmpty()) {
                                    ArrayList<String> output = new ArrayList<>();
                                    p = Pattern.compile(pattern);
                                    Matcher matcher = p.matcher(line);
                                    if (matcher.matches()) {
                                        for (int i = 1; i <= matcher.groupCount(); i++) {
                                            output.add(matcher.group(i).trim());
                                        }
                                    }
                                    String[] osmem_data = new String[output.size()];
                                    output.toArray(osmem_data);
                                    IOSTAT_BY_FUNCTION.addRow(osmem_data);
                                } else {
                                    break;
                                }
                            }
                            break;
                        case "TOP Timed Evenets":
                            pros.setText("Extracting data " + bagian + "...");
                            linebag++;
                            if (linebag == 2) {
                                String[] SGAADV_Kol = trim.split("\\s+");
                                TOP_N_TIMED_EVENTS.setColumnIdentifiers(SGAADV_Kol);
                            }
                            if (linebag == 3) {
                                int lengh;
                                pattern = "^";
                                String[] colpat = line.split("\\s+");
                                for (int i = 0; i < colpat.length - 1; i++) {
                                    lengh = colpat[i].length() + 1;
                                    pattern = pattern + "(.{" + Integer.toString(lengh) + "})";
                                }
                                pattern = pattern + "(.*)";
                            }
                            if (linebag > 3) {
                                if (!trim.isEmpty()) {
                                    ArrayList<String> output = new ArrayList<>();
                                    p = Pattern.compile(pattern);
                                    Matcher matcher = p.matcher(line);
                                    if (matcher.matches()) {
                                        for (int i = 1; i <= matcher.groupCount(); i++) {
                                            output.add(matcher.group(i).trim());
                                        }
                                    }
                                    String[] osmem_data = new String[output.size()];
                                    output.toArray(osmem_data);
                                    TOP_N_TIMED_EVENTS.addRow(osmem_data);
                                } else {
                                    break;
                                }
                            }
                            break;
                        case "SYSSTAT":
                            pros.setText("Extracting data " + bagian + "...");
                            linebag++;
                            if (linebag == 2) {
                                String[] SGAADV_Kol = trim.split("\\s+");
                                SYSSTAT.setColumnIdentifiers(SGAADV_Kol);
                            }
                            if (linebag == 3) {
                                int lengh;
                                pattern = "^";
                                String[] colpat = line.split("\\s+");
                                for (int i = 0; i < colpat.length - 1; i++) {
                                    lengh = colpat[i].length() + 1;
                                    pattern = pattern + "(.{" + Integer.toString(lengh) + "})";
                                }
                                pattern = pattern + "(.*)";
                            }
                            if (linebag > 3) {
                                if (!trim.isEmpty()) {
                                    ArrayList<String> output = new ArrayList<>();
                                    p = Pattern.compile(pattern);
                                    Matcher matcher = p.matcher(line);
                                    if (matcher.matches()) {
                                        for (int i = 1; i <= matcher.groupCount(); i++) {
                                            output.add(matcher.group(i).trim());
                                        }
                                    }
                                    String[] osmem_data = new String[output.size()];
                                    output.toArray(osmem_data);
                                    SYSSTAT.addRow(osmem_data);
                                } else {
                                    break;
                                }
                            }
                            break;
                        case "TOP SQL Summary":
                            pros.setText("Extracting data " + bagian + "...");
                            linebag++;
                            if (linebag == 2) {
                                String[] SGAADV_Kol = trim.split("\\s+");
                                TOP_SQL_SUMMARY.setColumnIdentifiers(SGAADV_Kol);
                            }
                            if (linebag == 3) {
                                int lengh;
                                pattern = "^";
                                String[] colpat = line.split("\\s+");
                                for (int i = 0; i < colpat.length - 1; i++) {
                                    lengh = colpat[i].length() + 1;
                                    pattern = pattern + "(.{" + Integer.toString(lengh) + "})";
                                }
                                pattern = pattern + "(.*)";
                            }
                            if (linebag > 3) {
                                if (!trim.isEmpty()) {
                                    ArrayList<String> output = new ArrayList<>();
                                    p = Pattern.compile(pattern);
                                    Matcher matcher = p.matcher(line);
                                    if (matcher.matches()) {
                                        for (int i = 1; i <= matcher.groupCount(); i++) {
                                            output.add(matcher.group(i).trim());
                                        }
                                    }
                                    String[] osmem_data = new String[output.size()];
                                    output.toArray(osmem_data);
                                    TOP_SQL_SUMMARY.addRow(osmem_data);
                                } else {
                                    break;
                                }
                            }
                            break;
                        case "TOP SQL by SNAPID":
                            pros.setText("Extracting data " + bagian + "...");
                            linebag++;
                            if (linebag == 2) {
                                String[] SGAADV_Kol = trim.split("\\s+");
                                TOP_SQL_BY_SNAPID.setColumnIdentifiers(SGAADV_Kol);
                            }
                            if (linebag == 3) {
                                int lengh;
                                pattern = "^";
                                String[] colpat = line.split("\\s+");
                                for (int i = 0; i < colpat.length - 1; i++) {
                                    lengh = colpat[i].length() + 1;
                                    pattern = pattern + "(.{" + Integer.toString(lengh) + "})";
                                }
                                pattern = pattern + "(.*)";
                            }
                            if (linebag > 3) {
                                if (!trim.isEmpty()) {
                                    ArrayList<String> output = new ArrayList<>();
                                    p = Pattern.compile(pattern);
                                    Matcher matcher = p.matcher(line);
                                    if (matcher.matches()) {
                                        for (int i = 1; i <= matcher.groupCount(); i++) {
                                            output.add(matcher.group(i).trim());
                                        }
                                    }
                                    String[] osmem_data = new String[output.size()];
                                    output.toArray(osmem_data);
                                    TOP_SQL_BY_SNAPID.addRow(osmem_data);
                                } else {
                                    break;
                                }
                            }
                            break;
                        case "Tablespace":
                            pros.setText("Extracting data " + bagian + "...");
                            linebag++;
                            if (linebag == 2) {
                                String[] SGAADV_Kol = trim.split("\\s+");
                                TABLESPACE.setColumnIdentifiers(SGAADV_Kol);
                            }
                            if (linebag == 3) {
                                int lengh;
                                pattern = "^";
                                String[] colpat = line.split("\\s+");
                                for (int i = 0; i < colpat.length - 1; i++) {
                                    lengh = colpat[i].length() + 1;
                                    pattern = pattern + "(.{" + Integer.toString(lengh) + "})";
                                }
                                pattern = pattern + "(.*)";
                            }
                            if (linebag > 3) {
                                if (!trim.isEmpty()) {
                                    ArrayList<String> output = new ArrayList<>();
                                    p = Pattern.compile(pattern);
                                    Matcher matcher = p.matcher(line);
                                    if (matcher.matches()) {
                                        for (int i = 1; i <= matcher.groupCount(); i++) {
                                            output.add(matcher.group(i).trim());
                                        }
                                    }
                                    String[] osmem_data = new String[output.size()];
                                    output.toArray(osmem_data);
                                    TABLESPACE.addRow(osmem_data);
                                } else {
                                    break;
                                }
                            }
                            break;
                        case "Invalid Object":
                            pros.setText("Extracting data " + bagian + "...");
                            linebag++;
                            if (linebag == 2) {
                                String[] SGAADV_Kol = trim.split("\\s+");
                                INVALID_OBJECT.setColumnIdentifiers(SGAADV_Kol);
                            }
                            if (linebag == 3) {
                                int lengh;
                                pattern = "^";
                                String[] colpat = line.split("\\s+");
                                for (int i = 0; i < colpat.length - 1; i++) {
                                    lengh = colpat[i].length() + 1;
                                    pattern = pattern + "(.{" + Integer.toString(lengh) + "})";
                                }
                                pattern = pattern + "(.*)";
                            }
                            if (linebag > 3) {
                                if (!trim.isEmpty()) {
                                    ArrayList<String> output = new ArrayList<>();
                                    p = Pattern.compile(pattern);
                                    Matcher matcher = p.matcher(line);
                                    if (matcher.matches()) {
                                        for (int i = 1; i <= matcher.groupCount(); i++) {
                                            output.add(matcher.group(i).trim());
                                        }
                                    }
                                    String[] osmem_data = new String[output.size()];
                                    output.toArray(osmem_data);
                                    INVALID_OBJECT.addRow(osmem_data);
                                } else {
                                    break;
                                }
                            }
                            break;
                        case "Analyze Table":
                            pros.setText("Extracting data " + bagian + "...");
                            linebag++;
                            if (linebag == 2) {
                                String[] SGAADV_Kol = trim.split("\\s+");
                                ANALYZE_TABLE.setColumnIdentifiers(SGAADV_Kol);
                            }
                            if (linebag == 3) {
                                int lengh;
                                pattern = "^";
                                String[] colpat = line.split("\\s+");
                                for (int i = 0; i < colpat.length - 1; i++) {
                                    lengh = colpat[i].length() + 1;
                                    pattern = pattern + "(.{" + Integer.toString(lengh) + "})";
                                }
                                pattern = pattern + "(.*)";
                            }
                            if (linebag > 3) {
                                if (!trim.isEmpty()) {
                                    ArrayList<String> output = new ArrayList<>();
                                    p = Pattern.compile(pattern);
                                    Matcher matcher = p.matcher(line);
                                    if (matcher.matches()) {
                                        for (int i = 1; i <= matcher.groupCount(); i++) {
                                            output.add(matcher.group(i).trim());
                                        }
                                    }
                                    String[] osmem_data = new String[output.size()];
                                    output.toArray(osmem_data);
                                    ANALYZE_TABLE.addRow(osmem_data);
                                } else {
                                    break;
                                }
                            }
                            break;
                        case "Resource Limit":
                            pros.setText("Extracting data " + bagian + "...");
                            linebag++;
                            if (linebag == 2) {
                                String[] SGAADV_Kol = trim.split("\\s+");
                                RESOURCE_LIMIT.setColumnIdentifiers(SGAADV_Kol);
                            }
                            if (linebag == 3) {
                                int lengh;
                                pattern = "^";
                                String[] colpat = line.split("\\s+");
                                for (int i = 0; i < colpat.length - 1; i++) {
                                    lengh = colpat[i].length() + 1;
                                    pattern = pattern + "(.{" + Integer.toString(lengh) + "})";
                                }
                                pattern = pattern + "(.*)";
                            }
                            if (linebag > 3) {
                                if (!trim.isEmpty()) {
                                    ArrayList<String> output = new ArrayList<>();
                                    p = Pattern.compile(pattern);
                                    Matcher matcher = p.matcher(line);
                                    if (matcher.matches()) {
                                        for (int i = 1; i <= matcher.groupCount(); i++) {
                                            output.add(matcher.group(i).trim());
                                        }
                                    }
                                    String[] osmem_data = new String[output.size()];
                                    output.toArray(osmem_data);
                                    RESOURCE_LIMIT.addRow(osmem_data);
                                } else {
                                    break;
                                }
                            }
                            break;
                        case "Resource Limit History":
                            pros.setText("Extracting data " + bagian + "...");
                            linebag++;
                            if (linebag == 2) {
                                String[] SGAADV_Kol = trim.split("\\s+");
                                RESOURCE_LIMIT_HIST.setColumnIdentifiers(SGAADV_Kol);
                            }
                            if (linebag == 3) {
                                int lengh;
                                pattern = "^";
                                String[] colpat = line.split("\\s+");
                                for (int i = 0; i < colpat.length - 1; i++) {
                                    lengh = colpat[i].length() + 1;
                                    pattern = pattern + "(.{" + Integer.toString(lengh) + "})";
                                }
                                pattern = pattern + "(.*)";
                            }
                            if (linebag > 3) {
                                if (!trim.isEmpty()) {
                                    ArrayList<String> output = new ArrayList<>();
                                    p = Pattern.compile(pattern);
                                    Matcher matcher = p.matcher(line);
                                    if (matcher.matches()) {
                                        for (int i = 1; i <= matcher.groupCount(); i++) {
                                            output.add(matcher.group(i).trim());
                                        }
                                    }
                                    String[] osmem_data = new String[output.size()];
                                    output.toArray(osmem_data);
                                    RESOURCE_LIMIT_HIST.addRow(osmem_data);
                                } else {
                                    break;
                                }
                            }
                            break;
                        case "Switch Log Frequency Map":
                            pros.setText("Extracting data " + bagian + "...");
                            linebag++;
                            if (linebag == 2) {
                                String[] SGAADV_Kol = trim.split("\\s+");
                                SWITCH_LOGFILE.setColumnIdentifiers(SGAADV_Kol);
                            }
                            if (linebag == 3) {
                                int lengh;
                                pattern = "^";
                                String[] colpat = line.split("\\s+");
                                for (int i = 0; i < colpat.length - 1; i++) {
                                    lengh = colpat[i].length() + 1;
                                    pattern = pattern + "(.{" + Integer.toString(lengh) + "})";
                                }
                                pattern = pattern + "(.*)";
                            }
                            if (linebag > 3) {
                                if (!trim.isEmpty()) {
                                    ArrayList<String> output = new ArrayList<>();
                                    p = Pattern.compile(pattern);
                                    Matcher matcher = p.matcher(line);
                                    if (matcher.matches()) {
                                        for (int i = 1; i <= matcher.groupCount(); i++) {
                                            output.add(matcher.group(i).trim());
                                        }
                                    }
                                    String[] osmem_data = new String[output.size()];
                                    output.toArray(osmem_data);
                                    SWITCH_LOGFILE.addRow(osmem_data);
                                } else {
                                    break;
                                }
                            }
                            break;
                        case "REDO LOG Info":
                            pros.setText("Extracting data " + bagian + "...");
                            linebag++;
                            if (linebag == 2) {
                                String[] SGAADV_Kol = trim.split("\\s+");
                                REDO.setColumnIdentifiers(SGAADV_Kol);
                            }
                            if (linebag == 3) {
                                int lengh;
                                pattern = "^";
                                String[] colpat = line.split("\\s+");
                                for (int i = 0; i < colpat.length - 1; i++) {
                                    lengh = colpat[i].length() + 1;
                                    pattern = pattern + "(.{" + Integer.toString(lengh) + "})";
                                }
                                pattern = pattern + "(.*)";
                            }
                            if (linebag > 3) {
                                if (!trim.isEmpty()) {
                                    ArrayList<String> output = new ArrayList<>();
                                    p = Pattern.compile(pattern);
                                    Matcher matcher = p.matcher(line);
                                    if (matcher.matches()) {
                                        for (int i = 1; i <= matcher.groupCount(); i++) {
                                            output.add(matcher.group(i).trim());
                                        }
                                    }
                                    String[] osmem_data = new String[output.size()];
                                    output.toArray(osmem_data);
                                    REDO.addRow(osmem_data);
                                } else {
                                    break;
                                }
                            }
                            break;
                        case "SGA":
                            pros.setText("Extracting data " + bagian + "...");
                            linebag++;
                            if (linebag == 2) {
                                String[] SGAADV_Kol = trim.split("\\s+");
                                SGA.setColumnIdentifiers(SGAADV_Kol);
                            }
                            if (linebag == 3) {
                                int lengh;
                                pattern = "^";
                                String[] colpat = line.split("\\s+");
                                for (int i = 0; i < colpat.length - 1; i++) {
                                    lengh = colpat[i].length() + 1;
                                    pattern = pattern + "(.{" + Integer.toString(lengh) + "})";
                                }
                                pattern = pattern + "(.*)";
                            }
                            if (linebag > 3) {
                                if (!trim.isEmpty()) {
                                    ArrayList<String> output = new ArrayList<>();
                                    p = Pattern.compile(pattern);
                                    Matcher matcher = p.matcher(line);
                                    if (matcher.matches()) {
                                        for (int i = 1; i <= matcher.groupCount(); i++) {
                                            output.add(matcher.group(i).trim());
                                        }
                                    }
                                    String[] osmem_data = new String[output.size()];
                                    output.toArray(osmem_data);
                                    SGA.addRow(osmem_data);
                                } else {
                                    break;
                                }
                            }
                            break;
                        case "SGA Info":
                            pros.setText("Extracting data " + bagian + "...");
                            linebag++;
                            if (linebag == 2) {
                                String[] SGAADV_Kol = trim.split("\\s+");
                                SGA_INFO.setColumnIdentifiers(SGAADV_Kol);
                            }
                            if (linebag == 3) {
                                int lengh;
                                pattern = "^";
                                String[] colpat = line.split("\\s+");
                                for (int i = 0; i < colpat.length - 1; i++) {
                                    lengh = colpat[i].length() + 1;
                                    pattern = pattern + "(.{" + Integer.toString(lengh) + "})";
                                }
                                pattern = pattern + "(.*)";
                            }
                            if (linebag > 3) {
                                if (!trim.isEmpty()) {
                                    String tem_pat = pattern;
                                    String[] osmem_data;
                                    List<String> data1;
                                    data1 = new ArrayList<>();
                                    p = Pattern.compile(pattern);
                                    Matcher matcher = p.matcher(line);
                                    if (matcher.matches()) {
                                        for (int i = 1; i <= matcher.groupCount(); i++) {
                                            data1.add(matcher.group(i).trim());
                                        }
                                    }
                                    if (!matcher.matches()) {
                                        pattern = "^(.{11})(.{33})(.*)";
                                        p = Pattern.compile(pattern);
                                        matcher = p.matcher(line);
                                        if (matcher.matches()) {
                                            for (int i = 1; i <= matcher.groupCount(); i++) {
                                                data1.add(matcher.group(i).trim());
                                            }
                                        }
                                    }
                                    osmem_data = data1.toArray(new String[0]);
                                    SGA_INFO.addRow(osmem_data);
                                    pattern = tem_pat;
                                } else {
                                    break;
                                }
                            }
                            break;
                        case "Buffer Pool":
                            pros.setText("Extracting data " + bagian + "...");
                            linebag++;
                            if (linebag == 2) {
                                String[] SGAADV_Kol = trim.split("\\s+");
                                BUFFER_POOL.setColumnIdentifiers(SGAADV_Kol);
                            }
                            if (linebag == 3) {
                                int lengh;
                                pattern = "^";
                                String[] colpat = line.split("\\s+");
                                for (int i = 0; i < colpat.length - 1; i++) {
                                    lengh = colpat[i].length() + 1;
                                    pattern = pattern + "(.{" + Integer.toString(lengh) + "})";
                                }
                                pattern = pattern + "(.*)";
                            }
                            if (linebag > 3) {
                                if (!trim.isEmpty()) {
                                    ArrayList<String> output = new ArrayList<>();
                                    p = Pattern.compile(pattern);
                                    Matcher matcher = p.matcher(line);
                                    if (matcher.matches()) {
                                        for (int i = 1; i <= matcher.groupCount(); i++) {
                                            output.add(matcher.group(i).trim());
                                        }
                                    }
                                    String[] osmem_data = new String[output.size()];
                                    output.toArray(osmem_data);
                                    BUFFER_POOL.addRow(osmem_data);
                                } else {
                                    break;
                                }
                            }
                            break;
                        case "Backup History":
                            pros.setText("Extracting data " + bagian + "...");
                            linebag++;
                            if (linebag == 2) {
                                String[] SGAADV_Kol = trim.split("\\s+");
                                BACKUP.setColumnIdentifiers(SGAADV_Kol);
                            }
                            if (linebag == 3) {
                                int lengh;
                                pattern = "^";
                                String[] colpat = line.split("\\s+");
                                for (int i = 0; i < colpat.length - 1; i++) {
                                    lengh = colpat[i].length() + 1;
                                    pattern = pattern + "(.{" + Integer.toString(lengh) + "})";
                                }
                                pattern = pattern + "(.*)";
                            }
                            if (linebag > 3) {
                                if (!trim.isEmpty()) {
                                    ArrayList<String> output = new ArrayList<>();
                                    p = Pattern.compile(pattern);
                                    Matcher matcher = p.matcher(line);
                                    if (matcher.matches()) {
                                        for (int i = 1; i <= matcher.groupCount(); i++) {
                                            output.add(matcher.group(i).trim());
                                        }
                                    }
                                    String[] osmem_data = new String[output.size()];
                                    output.toArray(osmem_data);
                                    BACKUP.addRow(osmem_data);
                                } else {
                                    break;
                                }
                            }
                            break;

                        case "ASM Diskgroup":
                            pros.setText("Extracting data " + bagian + "...");
                            linebag++;
                            if (linebag == 2) {
                                String[] SGAADV_Kol = trim.split("\\s+");
                                ASM_DISKGROUP.setColumnIdentifiers(SGAADV_Kol);
                            }
                            if (linebag == 3) {
                                int lengh;
                                pattern = "^";
                                String[] colpat = line.split("\\s+");
                                for (int i = 0; i < colpat.length - 1; i++) {
                                    lengh = colpat[i].length() + 1;
                                    pattern = pattern + "(.{" + Integer.toString(lengh) + "})";
                                }
                                pattern = pattern + "(.*)";
                            }
                            if (linebag > 3) {
                                if (!trim.isEmpty()) {
                                    ArrayList<String> output = new ArrayList<>();
                                    p = Pattern.compile(pattern);
                                    Matcher matcher = p.matcher(line);
                                    if (matcher.matches()) {
                                        for (int i = 1; i <= matcher.groupCount(); i++) {
                                            output.add(matcher.group(i).trim());
                                        }
                                    }
                                    String[] osmem_data = new String[output.size()];
                                    output.toArray(osmem_data);
                                    ASM_DISKGROUP.addRow(osmem_data);
                                } else {
                                    break;
                                }
                            }
                            break;

                        case "ASM Disk":
                            pros.setText("Extracting data " + bagian + "...");
                            linebag++;
                            if (linebag == 2) {
                                String[] SGAADV_Kol = trim.split("\\s+");
                                ASM_DISK.setColumnIdentifiers(SGAADV_Kol);
                            }
                            if (linebag == 3) {
                                int lengh;
                                pattern = "^";
                                String[] colpat = line.split("\\s+");
                                for (int i = 0; i < colpat.length - 1; i++) {
                                    lengh = colpat[i].length() + 1;
                                    pattern = pattern + "(.{" + Integer.toString(lengh) + "})";
                                }
                                pattern = pattern + "(.*)";
                            }
                            if (linebag > 3) {
                                if (!trim.isEmpty()) {
                                    ArrayList<String> output = new ArrayList<>();
                                    p = Pattern.compile(pattern);
                                    Matcher matcher = p.matcher(line);
                                    if (matcher.matches()) {
                                        for (int i = 1; i <= matcher.groupCount(); i++) {
                                            output.add(matcher.group(i).trim());
                                        }
                                    }
                                    String[] osmem_data = new String[output.size()];
                                    output.toArray(osmem_data);
                                    ASM_DISK.addRow(osmem_data);
                                } else {
                                    break;
                                }
                            }
                            break;
                        case "kosong":
                            if (jCheckBox3.isSelected()) {
                                if (line.length() > 2) {
                                    jTextArea1.append(line + "\n");
                                }
                            }
                            break;
                    }

                }
            }
            // close resources
            br.close();
            fr.close();
            pros.setText("Exporting To Excel File ... ");
            if (jCheckBox2.isSelected()) {
                try {
                    exporttoxl(jLabel2.getText());
                } catch (IOException ioe) {
                    JOptionPane.showMessageDialog(this, ioe);
                }
            }
            dlg.setVisible(false);
            System.gc();
        }
        //export to excel
        System.gc();

    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JButton jButton3;
    private javax.swing.JButton jButton4;
    private javax.swing.JCheckBox jCheckBox1;
    private javax.swing.JCheckBox jCheckBox2;
    private javax.swing.JCheckBox jCheckBox3;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel13;
    private javax.swing.JLabel jLabel14;
    private javax.swing.JLabel jLabel15;
    private javax.swing.JLabel jLabel16;
    private javax.swing.JLabel jLabel18;
    private javax.swing.JLabel jLabel19;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel20;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTabbedPane jTabbedPane1;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextField jTextField1;
    // End of variables declaration//GEN-END:variables

}
